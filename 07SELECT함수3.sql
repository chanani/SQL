-- 집합연산자
-- UNION - 합집합, UNIOON ALL - 합집합, INTERESECT - 교집합, MINUS - 차집합

-- UNION : 미쉘이 중복이기 때문에, 중복제거
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

-- UNIONALL : 합집합, 중복제거 안함
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

-- INTERSECT : 교집합
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

-- MINUS : 차집합
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

-- 집합연산자는 컴럼수가 일치해야합니다.
-- 컴럼수가 일치한다면, 다양한 형태로 사용이됩니다.
SELECT '홍길동', TO_CHAR(SYSDATE) FROM DUAL
UNION ALL
SELECT '이순신', '05/01/01' FROM DUAL
UNION ALL
SELECT '홍길자', '06/02/02' FROM DUAL
UNION ALL
SELECT LAST_NAME, TO_CHAR(HIRE_DATE) FROM EMPLOYEES;

-----------------------------------------------------------------
-- 분석함수 - 행에 대한 결과를 출력하는 기능, OVER()와 함께 사용됩니다.
SELECT FIRST_NAME, SALARY, 
       RANK() OVER(ORDER BY SALARY DESC) AS 중복순서 ,
       DENSE_RANK() OVER(ORDER BY SALARY DESC) AS 중복순서x,
       ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS 데이터번호,
       COUNT(*) OVER(), -- 전체 데이터 개수
       ROWNUM AS 조회순서 -- 조회가 일어난 순서
FROM EMPLOYEES;




